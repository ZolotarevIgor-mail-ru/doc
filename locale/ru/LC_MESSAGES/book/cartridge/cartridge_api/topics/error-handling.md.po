
msgid "Error handling guidelines"
msgstr ""

msgid ""
"Almost all errors in Cartridge follow `return nil, err` style, where "
"`err` is an error object produced by ``errors` "
"<https://github.com/tarantool/errors>`_ module. Cartridge doesn't raise "
"errors except for bugs and functions contracts mismatch. Developing new "
"roles should follow these guidelines as well."
msgstr ""

msgid "Error objects in Lua"
msgstr ""

msgid ""
"Error classes help to locate the problem's source. For this purpose, an "
"error object contains its class, stack traceback and a message."
msgstr ""

msgid ""
"local errors = require('errors')\n"
"local DangerousError = errors.new_class(\"DangerousError\")\n"
"\n"
"local function some_fancy_function()\n"
"\n"
"    local something_bad_happens = true\n"
"\n"
"    if something_bad_happens then\n"
"        return nil, DangerousError:new(\"Oh boy\")\n"
"    end\n"
"\n"
"    return \"success\" -- not reachable due to the error\n"
"end\n"
"\n"
"print(some_fancy_function())"
msgstr ""

msgid ""
"nil DangerousError: Oh boy\n"
"stack traceback:\n"
"    test.lua:9: in function 'some_fancy_function'\n"
"    test.lua:15: in main chunk"
msgstr ""

msgid "For uniform error handling `errors` provides `:pcall` API:"
msgstr ""

msgid ""
"local ret, err = DangerousError:pcall(some_fancy_function)\n"
"print(ret, err)"
msgstr ""

msgid ""
"nil DangerousError: Oh boy\n"
"stack traceback:\n"
"    test.lua:9: in function <test.lua:4>\n"
"    [C]: in function 'xpcall'\n"
"    .rocks/share/tarantool/errors.lua:139: in function 'pcall'\n"
"    test.lua:15: in main chunk"
msgstr ""

msgid "print(DangerousError:pcall(error, 'what could possibly go wrong?'))"
msgstr ""

msgid ""
"nil DangerousError: what could possibly go wrong?\n"
"stack traceback:\n"
"    [C]: in function 'xpcall'\n"
"    .rocks/share/tarantool/errors.lua:139: in function 'pcall'\n"
"    test.lua:15: in main chunk"
msgstr ""

msgid ""
"For `errors.pcall` there is no difference between `return nil, err` and "
"`error()` approaches."
msgstr ""

msgid ""
"Note that `errors.pcall` API differs from vanilla lua ``pcall` "
"<https://www.lua.org/pil/8.4.html>`_. Instead of `true` former returns "
"values returned from the call. If there is error, it returns `nil` "
"instead of `false`, plus error message."
msgstr ""

msgid ""
"Remote `net.box` calls don't keep stack trace from the remote. In that "
"case `errors.netbox_eval` comes to the rescue. It will find stack trace "
"from local and remote hosts and restore metatables."
msgstr ""

msgid ""
"> conn = require('net.box').connect('localhost:3301')\n"
"> print( errors.netbox_eval(conn, 'return nil, "
"DoSomethingError:new(\"oops\")') )\n"
"nil     DoSomethingError: oops\n"
"stack traceback:\n"
"        eval:1: in main chunk\n"
"during net.box eval on localhost:3301\n"
"stack traceback:\n"
"        [string \"return print( errors.netbox_eval(\"]:1: in main chunk\n"
"        [C]: in function 'pcall'"
msgstr ""

msgid ""
"However, vshard implemented in Tarantool doesn't utilize `errors` module."
" Instead it uses its own `errors "
"<https://github.com/tarantool/vshard/blob/master/vshard/error.lua>`_. "
"Keep this in mind when working with vshard functions."
msgstr ""

msgid ""
"Data included in error object (class name, message, traceback) may be "
"easily converted to string using `tostring()` function."
msgstr ""

msgid "GraphQL"
msgstr ""

msgid ""
"GraphQL implementation in cartridge wraps `errors` module so a typical "
"error response looks as follows:"
msgstr ""

msgid ""
"{\n"
"    \"errors\":[{\n"
"        \"message\":\"what could possibly go wrong?\",\n"
"        \"extensions\":{\n"
"            \"io.tarantool.errors.stack\":\"stack traceback: ...\",\n"
"            \"io.tarantool.errors.class_name\":\"DangerousError\"\n"
"        }\n"
"    }]\n"
"}"
msgstr ""

msgid ""
"Read more about errors in GraphQL specification `here "
"<http://spec.graphql.org/draft/#sec-Errors.Error-result-format>`_."
msgstr ""

msgid ""
"If you're going to implement GraphQL handler, you can add your own "
"extension like this:"
msgstr ""

msgid ""
"local err = DangerousError:new('I have extension')\n"
"err.graphql_extensions = {code = 403}"
msgstr ""

msgid "It will lead to the following response:"
msgstr ""

msgid ""
"{\n"
"    \"errors\":[{\n"
"        \"message\":\"I have extension\",\n"
"        \"extensions\":{\n"
"            \"io.tarantool.errors.stack\":\"stack traceback: ...\",\n"
"            \"io.tarantool.errors.class_name\":\"DangerousError\",\n"
"            \"code\":403\n"
"        }\n"
"    }]\n"
"}"
msgstr ""

msgid "HTTP"
msgstr ""

msgid ""
"In a nutshell `errors` object is a table. This means that it can be "
"swiftly represented as a json. Such approach is used by Cartridge to "
"handle errors via http:"
msgstr ""

msgid ""
"local err = DangerousError:new('Who would have thought?')\n"
"\n"
"local resp = req:render({\n"
"    status = 500,\n"
"    headers = {\n"
"        ['content-type'] = \"application/json; charset=utf-8\"\n"
"    },\n"
"    json = json.encode(err),\n"
"})"
msgstr ""

msgid ""
"{\n"
"    \"line\":27,\n"
"    \"class_name\":\"DangerousError\",\n"
"    \"err\":\"Who would have thought?\",\n"
"    \"file\":\".../app/roles/api.lua\",\n"
"    \"stack\":\"stack traceback:...\"\n"
"}"
msgstr ""
